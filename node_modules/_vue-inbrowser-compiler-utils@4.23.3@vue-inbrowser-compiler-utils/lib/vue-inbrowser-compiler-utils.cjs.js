(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.vueInbrowserCompilerUtils = {}));
}(this, (function (exports) { 'use strict';

	/* eslint-disable no-control-regex */
	// used to make CSS selectors remain scoped properly
	function scoper(css, suffix) {
	    var re = /([^\r\n,{}]+)(,(?=[^}]*{)|s*{)/g;
	    // `after` is going to contain eithe a comma or an opening curly bracket
	    css = css.replace(re, function (full, selector, after) {
	        // if non-rule delimiter
	        if (selector.match(/^\s*(@media|@keyframes|to|from|@font-face)/)) {
	            return selector + after;
	        }
	        // don't scope the part of the selector after ::v-deep
	        var arrayDeep = /(.*)(::v-deep|>>>|\/deep\/)(.*)/g.exec(selector);
	        if (arrayDeep) {
	            var beforeVDeep = arrayDeep[1], afterVDeep = arrayDeep[3];
	            selector = beforeVDeep;
	            after = afterVDeep + after;
	        }
	        // deal with :scope pseudo selectors
	        if (selector && selector.match(/:scope/)) {
	            selector = selector.replace(/([^\s]*):scope/, function (full, cutSelector) {
	                if (cutSelector === '') {
	                    return '> *';
	                }
	                return '> ' + cutSelector;
	            });
	        }
	        // deal with other pseudo selectors
	        var pseudo = '';
	        if (selector && selector.match(/:/)) {
	            var parts = selector.split(/:/);
	            selector = parts[0];
	            pseudo = ':' + parts[1];
	        }
	        selector = selector.trim() + ' ';
	        selector = selector.replace(/ /g, suffix + pseudo + ' ');
	        return selector + after;
	    });
	    return css;
	}

	/**
	 * Adds a style block to the head to load the styles.
	 * uses the suffix to scope the styles
	 * @param {string} css css code to add the the head
	 * @param {string} suffix string to add to each selector as a scoped style to avoid conflicts
	 */
	function addScopedStyle(css, suffix) {
	    // protect server side rendering
	    if (typeof document === 'undefined') {
	        return;
	    }
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var newstyle = document.createElement('style');
	    newstyle.dataset.cssscoper = 'true';
	    var csses = scoper(css, "[data-" + suffix + "]");
	    var styleany = newstyle;
	    if (styleany.styleSheet) {
	        styleany.styleSheet.cssText = csses;
	    }
	    else {
	        newstyle.appendChild(document.createTextNode(csses));
	    }
	    head.appendChild(newstyle);
	}

	var camelCase = require('camelcase');
	/**
	 * Groups atributes passed to a React pragma to the VueJS fashion
	 * @param h the VueJS createElement function passed in render functions
	 * @returns pragma usable in buble rendered JSX for VueJS
	 */
	function adaptCreateElement(h) {
	    return function (comp, attr) {
	        var children = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            children[_i - 2] = arguments[_i];
	        }
	        if (attr === undefined) {
	            return h(comp);
	        }
	        else if (!children.length) {
	            return h(comp, groupAttr(attr));
	        }
	        return h(comp, groupAttr(attr), children);
	    };
	}
	var rootAttributes = [
	    'staticClass',
	    'class',
	    'style',
	    'key',
	    'ref',
	    'refInFor',
	    'slot',
	    'scopedSlots',
	    'model'
	];
	var prefixedRE = /^(on|nativeOn|props|domProps|hook|v)([A-Z][a-zA-Z]+)?$/;
	var getRawName = function (name) {
	    return name.replace(/^(on|native(On|-on)|props|dom(Props|-props)|hook|v)-?/, '');
	};
	/**
	 * Make sure an object is an array
	 * and if it is not wrap it inside one
	 * @param a
	 */
	var makeArray = function (a) {
	    return Array.isArray(a) ? a : [a];
	};
	/**
	 * create a functoin out of two other
	 * @param fn1
	 * @param fn2
	 */
	var mergeFn = function (fn1, fn2) {
	    return function () {
	        var argzMain = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            argzMain[_i] = arguments[_i];
	        }
	        fn1 && fn1.apply(this, argzMain);
	        fn2 && fn2.apply(this, argzMain);
	    };
	};
	/**
	 * merge two members of the spread
	 * @param a
	 * @param b
	 */
	var merge = function (a, b) {
	    // initialization case
	    if (a === undefined) {
	        return b;
	    }
	    // merge of functions
	    if (typeof a === 'function' && typeof b === 'function') {
	        return mergeFn(a, b);
	    }
	    // merge of other options (like class)
	    return makeArray(a).concat(b);
	};
	var concatenate = function (src) {
	    var otherObj = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        otherObj[_i - 1] = arguments[_i];
	    }
	    src = src || {};
	    otherObj.forEach(function (obj) {
	        Object.keys(obj).forEach(function (key) {
	            src[key] = merge(src[key], obj[key]);
	        });
	    });
	    return src;
	};
	var groupAttr = function (attrsIn) {
	    if (!attrsIn) {
	        return undefined;
	    }
	    var attrsOut = {};
	    Object.keys(attrsIn).forEach(function (name) {
	        var value = attrsIn[name];
	        var ccName = camelCase(name);
	        if (rootAttributes.indexOf(ccName) > 0) {
	            attrsOut[ccName] = value;
	        }
	        else if (name === 'attrs') {
	            attrsOut.attrs = concatenate(attrsOut.attrs, value);
	        }
	        else if (prefixedRE.test(ccName)) {
	            var foundName = prefixedRE.exec(ccName);
	            if (foundName) {
	                var prefix = foundName[1];
	                var rawName = getRawName(name);
	                var camelCasedName = rawName.length ? rawName[0].toLowerCase() + rawName.slice(1) : '';
	                if (prefix === 'v') {
	                    if (!attrsOut.directives) {
	                        attrsOut.directives = [];
	                    }
	                    attrsOut.directives.push({
	                        name: camelCasedName,
	                        value: value
	                    });
	                }
	                else {
	                    if (!attrsOut[prefix]) {
	                        attrsOut[prefix] = {};
	                    }
	                    if (camelCasedName.length) {
	                        // if it is a litteral prefixed attribute
	                        attrsOut[prefix][camelCasedName] = merge(attrsOut[prefix][camelCasedName], value);
	                    }
	                    else {
	                        // if it is a spread
	                        concatenate(attrsOut[prefix], value);
	                    }
	                }
	            }
	        }
	        else {
	            attrsOut.attrs = attrsOut.attrs || {};
	            var finalName = /^data-/.test(name) ? name : ccName === 'xlinkHref' ? 'xlink:href' : ccName;
	            attrsOut.attrs[finalName] = value;
	        }
	    });
	    return attrsOut;
	};

	var PARTS = ['template', 'script'];
	function parseComponent(code) {
	    // reinintialize regexp after each tour
	    var partsRE = PARTS.reduce(function (ret, part) {
	        ret[part] = new RegExp("<" + part + "[^>]*>((.|\\n|\\r)+)</" + part + ">", 'g');
	        return ret;
	    }, {});
	    var descriptor = {};
	    var partsWithWrapper = {};
	    // extract all parts
	    PARTS.forEach(function (part) {
	        var res = partsRE[part].exec(code);
	        if (res) {
	            partsWithWrapper[part] = res[0];
	            descriptor[part] = res[1];
	        }
	    });
	    // make sure they are the only components of the code
	    var check = code;
	    var i = PARTS.length;
	    while (i-- && check.length) {
	        var withWrapper = partsWithWrapper[PARTS[i]];
	        if (withWrapper) {
	            check = check.replace(withWrapper, '').trim();
	        }
	    }
	    // we assume that
	    var styleRE = /(<style[^>]*>)([^<]+)(<.......)/g;
	    var styleFollowUpRE = /()([^<]+)(<.......)/g;
	    var styleAnalyzed = '';
	    var stylesWithWrapper = [];
	    var stylePart = styleRE.exec(check);
	    var styleHeader = stylePart ? stylePart[1] : '';
	    var styles;
	    while (stylePart) {
	        styleAnalyzed += stylePart[2];
	        if (stylePart[3] === '</style>') {
	            if (!styles) {
	                styles = [];
	            }
	            styles.push(styleAnalyzed);
	            stylesWithWrapper.push("" + styleHeader + styleAnalyzed + "</style>");
	            styleAnalyzed = '';
	            styleHeader = '';
	            // if we just started to analyze a new style tag
	            stylePart = styleRE.exec(check);
	            styleHeader = stylePart ? stylePart[1] : '';
	        }
	        else {
	            styleAnalyzed += stylePart[3];
	            styleFollowUpRE.lastIndex = styleRE.lastIndex;
	            stylePart = styleFollowUpRE.exec(check);
	        }
	    }
	    if (styles) {
	        descriptor.styles = styles;
	        var i_1 = styles.length;
	        while (i_1--) {
	            check = check.replace(stylesWithWrapper[i_1], '').trim();
	        }
	    }
	    return check.length ? {} : descriptor;
	}

	/**
	 * Determines if the given code is a VueSfc file
	 * It does not throw if the code is invalid, just returns `false`
	 * @param code JavaScript or vue code to analyze
	 */
	function isCodeVueSfc(code) {
	    var parts = parseComponent(code);
	    return !!parts.script || !!parts.template;
	}

	exports.adaptCreateElement = adaptCreateElement;
	exports.addScopedStyle = addScopedStyle;
	exports.concatenate = concatenate;
	exports.isCodeVueSfc = isCodeVueSfc;
	exports.parseComponent = parseComponent;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
