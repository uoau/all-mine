import { parseComponent, isCodeVueSfc } from 'vue-inbrowser-compiler-utils';
export { adaptCreateElement, addScopedStyle, concatenate, isCodeVueSfc } from 'vue-inbrowser-compiler-utils';
import { transform } from 'buble';
import walkes from 'walkes';
import { Parser } from 'acorn';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var UNNAMED = /import\s*['"]([^'"]+)['"];?/gi;
var NAMED = /import\s*(\*\s*as)?\s*(\w*?)\s*,?\s*(?:\{([\s\S]*?)\})?\s*from\s*['"]([^'"]+)['"];?/gi;
function alias(previousKey) {
    var key = previousKey.trim();
    var name = key.split(' as ');
    if (name.length > 1) {
        key = name.shift() || '';
    }
    return { key: key, name: name[0] };
}
function generate(keys, dep, base, fn, offset) {
    if (offset === void 0) { offset = 0; }
    var depEnd = dep.split('/').pop();
    var tmp = depEnd
        ? depEnd.replace(/\W/g, '_') + '$' + offset // uniqueness
        : '';
    var name = alias(tmp).name;
    dep = fn + "('" + dep + "')";
    var obj;
    var out = "const " + name + " = " + dep + ";";
    if (base) {
        out += "\nconst " + base + " = " + tmp + ".default || " + tmp + ";";
    }
    keys.forEach(function (key) {
        obj = alias(key);
        out += "\nconst " + obj.name + " = " + tmp + "." + obj.key + ";";
    });
    return out;
}
function rewriteImports (str, offset, fn) {
    if (fn === void 0) { fn = 'require'; }
    return str
        .replace(NAMED, function (_, asterisk, base, req, dep) {
        return generate(req ? req.split(',').filter(function (d) { return d.trim(); }) : [], dep, base, fn, offset);
    })
        .replace(UNNAMED, function (_, dep) { return fn + "('" + dep + "');"; });
}

function transformOneImport(node, code, offset) {
    var start = node.start + offset;
    var end = node.end + offset;
    var statement = code.substring(start, end);
    var transpiledStatement = rewriteImports(statement, offset);
    code = code.substring(0, start) + transpiledStatement + code.substring(end);
    offset += transpiledStatement.length - statement.length;
    return { code: code, offset: offset };
}

var jsx = require('acorn-jsx');
var extendedParser = Parser.extend(jsx());
function getAst(code) {
    return extendedParser.parse(code, {
        ecmaVersion: 2019,
        sourceType: 'module'
    });
}

var buildStyles = function (styles) {
    var _styles = '';
    if (styles) {
        styles.forEach(function (it) {
            if (it) {
                _styles += it;
            }
        });
    }
    if (_styles !== '') {
        return _styles.trim();
    }
    return undefined;
};
function getSingleFileComponentParts(code) {
    var parts = parseComponent(code);
    if (parts.script)
        parts.script = parts.script.replace(/\/\*[\s\S]*?\*\/|([^:]|^)\/\/.*$/gm, '$1');
    return parts;
}
function injectTemplateAndParseExport(parts) {
    var templateString = parts.template ? parts.template.replace(/`/g, '\\`') : undefined;
    if (!parts.script)
        return { component: "{\ntemplate: `" + templateString + "` }" };
    var comp = parseScriptCode(parts.script);
    if (templateString) {
        comp.component = "{\n  template: `" + templateString + "`,\n  " + comp.component + "}";
    }
    else {
        comp.component = "{\n  " + comp.component + "}";
    }
    return comp;
}
function parseScriptCode(code) {
    var preprocessing = '';
    var startIndex = -1;
    var endIndex = -1;
    var offset = 0;
    var renderFunctionStart = -1;
    walkes(getAst(code), {
        //export const MyComponent = {}
        ExportNamedDeclaration: function (node) {
            preprocessing = code.slice(0, node.start + offset);
            startIndex = node.declaration.declarations[0].init.start + offset;
            endIndex = node.declaration.declarations[0].init.end + offset;
            if (node.declarations) {
                renderFunctionStart = getRenderFunctionStart(node.declarations[0]);
            }
        },
        //export default {}
        ExportDefaultDeclaration: function (node) {
            preprocessing = code.slice(0, node.start + offset);
            startIndex = node.declaration.start + offset;
            endIndex = node.declaration.end + offset;
            renderFunctionStart = getRenderFunctionStart(node.declaration);
        },
        //module.exports = {}
        AssignmentExpression: function (node) {
            if (/exports/.test(node.left.name) ||
                (node.left.object &&
                    /module/.test(node.left.object.name) &&
                    /exports/.test(node.left.property.name))) {
                preprocessing = code.slice(0, node.start + offset);
                startIndex = node.right.start + offset;
                endIndex = node.right.end + offset;
            }
        },
        // and transform import statements into require
        ImportDeclaration: function (node) {
            var ret = transformOneImport(node, code, offset);
            offset = ret.offset;
            code = ret.code;
        }
    });
    if (startIndex === -1) {
        throw new Error('Failed to parse single file component: ' + code);
    }
    if (renderFunctionStart > 0) {
        renderFunctionStart += offset;
        code = insertCreateElementFunction(code.slice(0, renderFunctionStart + 1), code.slice(renderFunctionStart + 1));
        endIndex += JSX_ADDON_LENGTH;
    }
    var component = code.slice(startIndex + 1, endIndex - 1);
    return {
        preprocessing: preprocessing,
        component: component,
        postprocessing: code.slice(endIndex)
    };
}
var JSX_ADDON_LENGTH = 31;
function getRenderFunctionStart(objectExpression) {
    if (objectExpression && objectExpression.properties) {
        var nodeProperties = objectExpression.properties;
        var renderFunctionObj = nodeProperties.find(function (p) { return p.key && p.key.type === 'Identifier' && p.key.name === 'render'; });
        if (renderFunctionObj && renderFunctionObj.value.body) {
            return renderFunctionObj.value.body.start;
        }
    }
    return -1;
}
function insertCreateElementFunction(before, after) {
    return before + "\nconst h = this.$createElement;" + after;
}
/**
 * Coming out of this function all SFC should be in the `new Vue()` format
 * it should as well have been stripped of exports and all imports should have been
 * transformed into requires
 */
function normalizeSfcComponent(code) {
    var parts = getSingleFileComponentParts(code);
    var extractedComponent = injectTemplateAndParseExport(parts);
    return {
        script: [
            extractedComponent.preprocessing,
            ";return " + extractedComponent.component,
            extractedComponent.postprocessing
        ].join('\n'),
        style: buildStyles(parts.styles)
    };
}

/**
 * Reads the code in string and separates the javascript part and the html part
 * then sets the nameVarComponent variable with the value of the component parameters
 * @param code
 * @param config buble config to be used when transforming
 *
 */
function compileVueCodeForEvalFunction(code, config) {
    if (config === void 0) { config = {}; }
    var nonCompiledComponent = prepareVueCodeForEvalFunction(code, config);
    return __assign(__assign({}, nonCompiledComponent), { script: transform(nonCompiledComponent.script, config).code });
}
function prepareVueCodeForEvalFunction(code, config) {
    var style, vsgMode = false, template;
    // if the component is written as a Vue sfc,
    // transform it in to a "return"
    // even if jsx is used in an sfc we still use this use case
    if (isCodeVueSfc(code)) {
        return normalizeSfcComponent(code);
    }
    // if it's not a new Vue, it must be a simple template or a vsg format
    // lets separate the template from the script
    if (!/new Vue\(/.test(code)) {
        // this for jsx examples without the SFC shell
        // export default {render: (h) => <Button>}
        if (config.jsx) {
            var _a = parseScriptCode(code), preprocessing = _a.preprocessing, component = _a.component, postprocessing = _a.postprocessing;
            return {
                script: preprocessing + ";\nreturn {" + component + "};\n" + postprocessing
            };
        }
        var findStartTemplateMatch = /^\W*</.test(code) ? { index: 0 } : code.match(/\n[\t ]*</);
        var limitScript = findStartTemplateMatch && findStartTemplateMatch.index !== undefined
            ? findStartTemplateMatch.index
            : -1;
        template = limitScript > -1 ? code.slice(limitScript) : undefined;
        code = limitScript > -1 ? code.slice(0, limitScript) : code;
        vsgMode = true;
    }
    var ast = getAst(code);
    var offset = 0;
    var varNames = [];
    walkes(ast, __assign({ 
        // replace `new Vue({data})` by `return {data}`
        ExpressionStatement: function (node) {
            if (node.expression.type === 'NewExpression' && node.expression.callee.name === 'Vue') {
                var before = code.slice(0, node.expression.start + offset);
                var optionsNode = node.expression.arguments && node.expression.arguments.length
                    ? node.expression.arguments[0]
                    : undefined;
                var renderIndex = getRenderFunctionStart(optionsNode);
                var endIndex = optionsNode.end;
                if (renderIndex > 0) {
                    code = insertCreateElementFunction(code.slice(0, renderIndex + 1), code.slice(renderIndex + 1));
                    endIndex += JSX_ADDON_LENGTH;
                }
                var after = optionsNode ? code.slice(optionsNode.start + offset, endIndex + offset) : '';
                code = before + ';return ' + after;
            }
        },
        // transform all imports into require function calls
        ImportDeclaration: function (node) {
            var ret = transformOneImport(node, code, offset);
            offset = ret.offset;
            code = ret.code;
            if (vsgMode && node.specifiers) {
                node.specifiers.forEach(function (s) { return varNames.push(s.local.name); });
            }
        } }, (vsgMode
        ? {
            VariableDeclaration: function (node) {
                node.declarations.forEach(function (declaration) {
                    if (declaration.id.name) {
                        // simple variable declaration
                        varNames.push(declaration.id.name);
                    }
                    else if (declaration.id.properties) {
                        // spread variable declaration
                        // const { all:names } = {all: 'foo'}
                        declaration.id.properties.forEach(function (p) {
                            varNames.push(p.value.name);
                        });
                    }
                });
            },
            FunctionDeclaration: function (node) {
                varNames.push(node.id.name);
            }
        }
        : {})));
    if (vsgMode) {
        code += ";return {data:function(){return {" + 
        // add local vars in data
        // this is done through an object like {varName: varName}
        // since each varName is defined in compiledCode, it can be used to init
        // the data object here
        varNames.map(function (varName) { return varName + ":" + varName; }).join(',') + "};}}";
    }
    return {
        script: code,
        style: style,
        template: template
    };
}

export { compileVueCodeForEvalFunction as compile };
